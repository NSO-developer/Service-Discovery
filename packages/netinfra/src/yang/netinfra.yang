module netinfra {
  namespace "http://example.com/respnet/netinfra";
  prefix netinfra;

  import ietf-inet-types {
    prefix inet;
  }
  import tailf-common {
    prefix tailf;
  }
  import tailf-ncs {
    prefix ncs;
  }

  description
    "Bla bla...";

  revision 2016-01-01 {
    description
      "Initial revision.";
  }

  container netinfra {
    description "Network Infrastructure";

      tailf:action find-services {
        tailf:actionpoint netinfra-find-services;
        input {
          leaf service-type {
            type enumeration {
              enum "router";
              enum "backbone-link";
              enum "all";
            }
            default "all";
          }
          leaf dry-run {
            type empty;
          }
          leaf reconcile-type {
            type enumeration {
              enum "keep-non-service-config";
              enum "discard-non-service-config";
            }
            default "keep-non-service-config";
          }
        }
        output {
          leaf success {
            type boolean;
          }
          leaf message {
            type string;
          }
          uses ncs:dry-run-cli;
        }
      }

    list router {
      key name;
      leaf name {
        description "Name of the router";
        tailf:cli-allow-range;
        type string;
      }

      uses ncs:service-data;
      ncs:servicepoint netinfra-router-servicepoint;

      list role {
        key "name";
        leaf name {
          type enumeration {
            enum "core";
            enum "edge";
            enum "peering";
          }
        }
      }

      leaf netsim {
        type boolean;
        tailf:hidden "debug";
      }

      container custom {
        tailf:info "Optional configurations that will be generated by the service if not present.";
        leaf id {
          type uint32;
        }
        leaf ipv4-address {
          type inet:ipv4-address;
        }
        leaf ipv6-address {
          type inet:ipv6-address;
        }
      }
      // BEGIN_STRIP
      container vars {
        config false;
        tailf:cdb-oper {
          tailf:persistent "true";
        }
        description "Template variables";

        leaf id {
          type uint32;
          description "ID";
          mandatory "true";
        }

        leaf ipv4-address {
          type inet:ipv4-address;
          mandatory true;
        }

        leaf ipv6-address {
          type inet:ipv6-address;
          mandatory true;
        }
      }
      // END_STRIP
    }

    list backbone-link {
      key "left-router left-interface right-router right-interface";

      uses ncs:service-data;
      uses ncs:nano-plan-data;
      ncs:servicepoint netinfra-backbone-link-servicepoint;

      leaf left-router {
        type leafref {
          path "/netinfra:netinfra/netinfra:router/netinfra:name";
        }
        tailf:cli-allow-range;
      }
      leaf left-interface {
        tailf:info "Interface name, e.g. HundredGigE0/0/0/0";
        tailf:cli-allow-range;
        type string;
      }
      leaf right-router {
        type leafref {
          path "/netinfra:netinfra/netinfra:router/netinfra:name";
        }
        tailf:cli-allow-range;
      }
      leaf right-interface {
        tailf:info "Interface name, e.g. HundredGigE0/0/0/0";
        tailf:cli-allow-range;
        type string;
      }
      leaf status {
        type enumeration {
          enum "up";
          enum "down";
        }
      }

      container custom {
        tailf:info "Optional configurations that will be generated by the service if not present.";
        leaf ipv4-prefix {
          type inet:ipv4-prefix;
        }
        leaf ipv6-prefix {
          type inet:ipv6-prefix;
        }
      }

      container vars {
        config false;
        tailf:cdb-oper {
          tailf:persistent "true";
        }
        description "Template variables";
        leaf ipv4-prefix {
          type inet:ipv4-prefix;
          mandatory true;
        }

        leaf ipv6-prefix {
          type inet:ipv6-prefix;
          mandatory true;
        }
        leaf left-ipv4-address {
          type inet:ipv4-address;
          description "IPv4 address of the left router";
        }
        leaf right-ipv4-address {
          type inet:ipv4-address;
          description "IPv4 address of the left router";
        }
        leaf ipv4-prefix-length {
          type uint8 {
            range "30..31";
          }
          description "IPv4 prefix length";
        }
        leaf left-ipv6-address {
          type inet:ipv6-address;
          description "IPv6 address of the right router";
        }
        leaf right-ipv6-address {
          type inet:ipv6-address;
          description "IPv6 address of the right router";
        }
        leaf ipv6-prefix-length {
          // We allow 64, 112 and 126
          type uint8 {
            range "64..64|112..112|126..127";
          }
          description "IPv6 prefix length";
        }

        leaf left-ipv4-loopback-address {
          type inet:ipv4-address;
          description "IPv4 loopback address of the left router";
        }
        leaf right-ipv4-loopback-address {
          type inet:ipv4-address;
          description "IPv4 loopback address of the left router";
        }
        leaf left-ipv6-loopback-address {
          type inet:ipv6-address;
          description "IPv6 loopback address of the left router";
        }
        leaf right-ipv6-loopback-address {
          type inet:ipv6-address;
          description "IPv6 loopback address of the left router";
        }

        leaf left-ibgp-type {
          type enumeration {
            enum "full-mesh";
            enum "rr-client";
            enum "direct";
            enum "none";
          }
          description "Type of iBGP neighbor from left router";
        }
        leaf right-ibgp-type {
          type enumeration {
            enum "full-mesh";
            enum "rr-client";
            enum "direct";
            enum "none";
          }
          description "Type of iBGP neighbor from right router";
        }
      }
    }

  }
  identity backbone-link-create-rfs {
    base ncs:plan-state;
    description "Awaiting routers resources to be allocated";
  }

  ncs:plan-outline netinfra-backbone-link-plan {
  ncs:self-as-service-status;
    ncs:component-type "ncs:self" {
      ncs:state "ncs:init";
      ncs:state "netinfra:backbone-link-create-rfs" {
        ncs:create {
          ncs:pre-condition {
            ncs:all {
              ncs:monitor  "/netinfra:netinfra/netinfra:router[name=$LEFT_ROUTER]/vars" {
                ncs:trigger-expr "ipv4-address != '' and ipv6-address != ''";
              }
              ncs:monitor  "/netinfra:netinfra/netinfra:router[name=$RIGHT_ROUTER]/vars" {
                ncs:trigger-expr "ipv4-address != '' and ipv6-address != ''";
              }
            }
          }
          ncs:nano-callback;
        }
      }
      ncs:state "ncs:ready";
    }
  }

  ncs:service-behavior-tree netinfra-backbone-link-servicepoint {
    ncs:plan-outline-ref netinfra-backbone-link-plan;
    ncs:selector {
      ncs:variable "LEFT_ROUTER" {
        ncs:value-expr "left-router";
      }
      ncs:variable "RIGHT_ROUTER" {
        ncs:value-expr "right-router";
      }
      ncs:create-component "'self'" {
        ncs:component-type-ref "ncs:self";
      }
    }
  }
}
